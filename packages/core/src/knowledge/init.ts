// @x-code/core â€” Project initialization (xc init / /init)
import fs from 'node:fs/promises'
import path from 'node:path'

import { getAutoMemory } from './auto-memory.js'
import { scanProject } from './hooks.js'

const XCODE_DIR = '.x-code'

interface InitResult {
  detectedFacts: string[]
  createdFiles: string[]
}

/** Initialize .x-code/ project structure and generate knowledge from project analysis */
export async function initProject(cwd: string = process.cwd()): Promise<InitResult> {
  const xDir = path.join(cwd, XCODE_DIR)
  const detectedFacts: string[] = []
  const createdFiles: string[] = []

  // Create directories
  const dirs = [
    xDir,
    path.join(xDir, 'memory'),
    path.join(xDir, 'rules'),
    path.join(xDir, 'sessions'),
    path.join(xDir, 'plans'),
    path.join(xDir, 'local'),
  ]

  for (const dir of dirs) {
    await fs.mkdir(dir, { recursive: true })
  }

  // Scan project and populate auto memory
  await scanProject(cwd)
  const memory = getAutoMemory('project')
  const facts = memory.getAll()

  for (const fact of facts) {
    detectedFacts.push(`${fact.key}: ${fact.fact}`)
  }

  // Generate knowledge.md
  const knowledgePath = path.join(xDir, 'knowledge.md')
  const knowledgeExists = await fileExists(knowledgePath)
  if (!knowledgeExists) {
    const knowledgeContent = generateKnowledgeMd(facts.map((f) => ({ key: f.key, fact: f.fact, category: f.category })))
    await fs.writeFile(knowledgePath, knowledgeContent, 'utf-8')
    createdFiles.push('.x-code/knowledge.md')
  }

  // Create .x-code/local/.gitignore if not exists
  const localGitignore = path.join(xDir, 'local', '.gitignore')
  if (!(await fileExists(localGitignore))) {
    await fs.writeFile(localGitignore, '*\n', 'utf-8')
    createdFiles.push('.x-code/local/.gitignore')
  }

  // Create .x-code/local/preferences.md template if not exists
  const prefsPath = path.join(xDir, 'local', 'preferences.md')
  if (!(await fileExists(prefsPath))) {
    await fs.writeFile(
      prefsPath,
      '# Personal Preferences\n\n<!-- Add your personal coding preferences here. This file is gitignored. -->\n',
      'utf-8',
    )
    createdFiles.push('.x-code/local/preferences.md')
  }

  // Ensure rules dir has a README
  const rulesReadme = path.join(xDir, 'rules', 'README.md')
  if (!(await fileExists(rulesReadme))) {
    await fs.writeFile(
      rulesReadme,
      `# Rules

Place \`.md\` rule files here. Each rule supports optional frontmatter:

\`\`\`yaml
---
alwaysApply: true          # Always load into context
paths: ["src/**/*.ts"]     # Load when matching files are active
description: "..."         # Listed for agent to request on demand
---
\`\`\`

Rules without frontmatter can be loaded manually via \`@rule-name\` in chat.
`,
      'utf-8',
    )
    createdFiles.push('.x-code/rules/README.md')
  }

  if (createdFiles.includes('.x-code/knowledge.md')) {
    createdFiles.push('.x-code/memory/auto.md')
  }

  return { detectedFacts, createdFiles }
}

function generateKnowledgeMd(facts: { key: string; fact: string; category: string }[]): string {
  const lines = [
    '# Project Knowledge',
    '',
    '<!-- Auto-generated by xc init. Feel free to edit and add business context. -->',
    '',
  ]

  const byCategory = new Map<string, { key: string; fact: string }[]>()
  for (const f of facts) {
    const list = byCategory.get(f.category) ?? []
    list.push({ key: f.key, fact: f.fact })
    byCategory.set(f.category, list)
  }

  for (const [category, items] of byCategory) {
    lines.push(`## ${category}`)
    for (const item of items) {
      lines.push(`- **${item.key}**: ${item.fact}`)
    }
    lines.push('')
  }

  lines.push(
    '## Business Context',
    '',
    '<!-- Describe your project purpose, domain, and any important conventions here. -->',
    '',
  )

  return lines.join('\n')
}

async function fileExists(filePath: string): Promise<boolean> {
  try {
    await fs.access(filePath)
    return true
  } catch {
    return false
  }
}
